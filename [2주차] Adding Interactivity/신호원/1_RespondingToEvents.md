# 이벤트 헨들러

기본적으로 함수를 정의해서 내부에 기능을 구현한 뒤 JSX 태그에 prop으로 전달해야 한다.

관습적으로 컴포넌트 내부에서 정의하고 `handle` 뒤에 이벤트 이름을 붙여 네이밍한다.
로직이 짧을 경우 태그의 prop 전달 값 내부에서 정의하기도 하는데 이를 inline 이벤트 헨들러라고 한다.

prop으로 전달해야 하는 것은 함수 객체 자체로 전달 값 내부에서 핸들러에 괄호를 붙여 실행시켜버리면 안된다.
만약 그렇게 한다면 컴포넌트가 렌더링될 때마다 핸들러가 실행된다. 단순한 로직 만을 전달하고 싶다면 익명함수로 감싸서 전달하는 게 일반적이다.

이벤트 헨들러는 컴포넌트에 인자로 전달된 값을 로직에 사용할 수도 있다. 또한 아예 핸들러 자체를 인자로 받아서 사용할 수도 있다.

기본으로 존재하는 내장 컴포넌트들은 이미 정의된 이벤트 속성을 가지지만 이를 감싸 새로운 컴포넌트를 정의하고 핸들러를 인수로 전달한다면 다양한 이름의 이벤트 속성처럼 사용할 수 있다. 관습적으로 `on` 뒤에 이벤트 이름을 붙여 네이밍한다.

인자로 전달받는 핸들러의 네이밍을 역할이 나타나도록 짓는다면 부모 컴포넌트에서 핸들러를 전달하기 용이해진다.

html에서 기본적으로 이벤트들은 상위 태그로 전파된다. 이를 이벤트 버블링이라고 한다.

이를 제어하고 싶다면 핸들러가 받는 `event` 객체의 메서드인 `stopPropagation` 을 호출할 수 있다. 

이벤트 버블링과 반대로 이벤트 캡처링도 있다. 태그의 이벤트 속성 뒤에 `Capture` 를 붙이면 캡처링 과정에서 실행된다.

인자로 전달받은 핸들러를 바로 이벤트 속성에 붙이지 않고 로직을 추가한 뒤 전파를 막아 사용할 수 있다. 이러한 패턴은 이벤트 버블링을 활용하는 로직을 사용하고 있었다면 대안이 될 수 있다. 이벤트 버블링에 비해 어떤 핸들러가 실행되었는 지 추적하기 쉽다.

html 요소가 이벤트에 대해 갖고 있는 기본 이벤트를 막고 싶다면 `event` 객체의 `preventDefault` 메서드를 호출할 수 있다.

이벤트 핸들러는 컴포넌트 내부 로직과 달리 순수 함수일 필요가 없으며 side effect가 위치하기 가장 바람직한 곳이다.