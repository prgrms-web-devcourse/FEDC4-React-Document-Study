# reducer 전환
컴포넌트가 복잡해진다면 state 업데이트 로직이 한눈에 파악하기 어려워진다. 로직을 컴포넌트 외부로 분리하는 방법으로 `reducer`가 있다.

reducer는 로직은 외부에서 구현한 뒤 컴포넌트 내부에서는 action을 dispatch해서 상태를 설정한다. 이는 명령형 방식이 아닌 선언형 방식으로 사용자의 의도를 더 명확히 나타낼 수 있다.

dispatch 메서드에 인수로 전달하는 객체를 action 객체라고 한다. action은 내부에 type 속성을 가지고 이를 통해 어떤 action인지 선언한다. 필요한 데이터는 다른 속성을 설정해서 로직에 전달해줄 수 있다.

로직을 담고있는 reducer 함수는 `task`를 첫 번째 매개변수로, `action`을 두 번째 매개변수로 받는다. `task`는 현재 상태 데이터를 가지고 있다. reducer 함수는 다음 상태를 반환해야 한다. `action`은 dispatch에서 전달한 그 인자로 일반적으로 type 속성을 switch 문을 통해 분기하여 사용한다.

reducer라는 이름은 배열의 메서드인 `reduce`에서 딴 것이다. 이는 연속된 action을 하나의 state로 누적한다는 점에서 동작이 비슷하기 때문이다.

컴포넌트에서 사용할 때는 `useReducer` Hook을 사용한다. 첫 번째 인수로는 reducer 함수를, 두 번째 인수로는 task의 초기값을 전달한다. 반환되는 값은 tasks 객체와 dispatch 메서드로 이루어진 배열이다.

# useState vs useReducer
각자 장단점이 존재한다.
- 코드 크기: 일반적으로 `useState`가 적지만 비슷한 state 업데이트 로직이 반복되는 경우 `useReducer`를 통해 줄일 수도 있다.
- 가독성: state의 구조가 복잡해질 수록 `useState`는 한눈에 읽기 어려워진다.
- 디버깅: `useReducer`는 reducer 함수에 로그를 추가하여 쉽게 디버깅 위치를 찾을 수 있다. 하지만 더 많은 코드를 살펴봐야 한다.
- 테스트: reducer는 순수함수로 별도로 분리해서 테스트하기 용이하다.
- 개취: 둘은 변환이 쉽다.

# 주의점
- reducer는 렌더링 중에 실행되므로 항상 순수 함수여야 한다.
- 각 action은 여러 데이터를 변경하더라도 하나의 사용자 상호작용을 설명해야 한다.